//linked list implementation 
//example of add students menu

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct student {
    int id;
    char name[20];
};

struct node {
    struct student stu;
    struct node *pPrev;
    struct node *pNext;
};

struct node *pHead;
struct node *pTail;

// Function prototypes
void print_student(struct student s);
struct student fill_student(void);
struct node *createNode(struct student s);
int addNode(void);
int insertNode(int location);
struct student searchByIdNode(int id);
struct student searchByNameNode(char name[]);
int deleteNode(int loc);
int deleteNodeById(int id);
void printList(void);
void freeList(void);

// end of prototype

int main() {
    int input_val, loc, input_id, flag = 1, retval;
    char input_name[20];

    printf("1-Add\n2-Insert\n3-Search by ID\n4-Search by name\n5-Delete student\n6-Delete list\n7-Print students\n8-Exit\n");

    while (flag) {
        scanf("%d", &input_val);
        switch (input_val) {
            case 1:
                retval = addNode();
                if (retval) {
                    printf("Student added successfully.\n");
                } else {
                    printf("Cannot add student.\n");
                }
                break;

            case 2:
                printf("Please enter location:\n");
                scanf("%d", &loc);
                retval = insertNode(loc);
                if (retval) {
                    printf("Student added successfully.\n");
                } else {
                    printf("Cannot add student.\n");
                }
                break;

            case 3:
                printf("Please enter ID:\n");
                scanf("%d", &input_id);
                struct student s = searchByIdNode(input_id);
                if (s.id == -1) {
                    printf("Student not found.\n");
                } else {
                    printf("Student found.\n");
                    print_student(s);
                }
                break;

            case 4:
                printf("Please enter name:\n");
                scanf("%s", input_name);
                s = searchByNameNode(input_name);
                if (strcmp(s.name, "") == 0) {
                    printf("Student not found.\n");
                } else {
                    printf("Student found.\n");
                    print_student(s);
                }
                break;

            case 5:
                printf("Please enter location:\n");
                scanf("%d", &loc);
                retval = deleteNode(loc);
                if (retval) {
                    printf("Student deleted successfully.\n");
                } else {
                    printf("Cannot delete student.\n");
                }
                break;

            case 6:
                freeList();
                printf("List deleted.\n");
                break;

            case 7:
                printList();
                break;

            case 8:
                flag = 0;
                break;
        }
    }

    return 0;
}

void print_student(struct student s) {
    printf("Student ID: %d\n", s.id);
    printf("Student name: %s\n", s.name);
}

struct student fill_student(void) {
    struct student s;
    printf("Enter student ID: ");
    scanf("%d", &(s.id));
    printf("Enter student name: ");
    scanf("%s", s.name);
    return s;
}

struct node *createNode(struct student s) {
    struct node *ptr = (struct node *)malloc(sizeof(struct node));
    if (ptr) {
        ptr->stu = s;
        ptr->pNext = NULL;
        ptr->pPrev = NULL;
    }
    return ptr;
}

int addNode(void) {
    struct student s = fill_student();
    struct node *ptr = createNode(s);

    int return_val = 0;

    if (ptr) {
        return_val = 1;
        if (pHead == NULL) {
            pHead = ptr;
            pTail = ptr;
        } else {
            pTail->pNext = ptr;
            ptr->pPrev = pTail;
            pTail = ptr;
        }
    }

    return return_val;
}

int insertNode(int location) {
    struct student s = fill_student();
    struct node *ptr = createNode(s);
    int return_val = 0, i;
    struct node *temp;

    if (ptr) {
        return_val = 1;
        if (pHead == NULL) {
            pHead = pTail = ptr;
        } else {
            if (location == 0) {
                ptr->pNext = pHead;
                pHead->pPrev = ptr;
                pHead = ptr;
            } else {
                temp = pHead;

                for (i = 0; i < location - 1 && (temp->pNext); i++) {
                    temp = temp->pNext;
                }

                if (temp == NULL || temp == pTail) {
                    pTail->pNext = ptr;
                    ptr->pPrev = pTail;
                    pTail = ptr;
                } else {
                    (temp->pNext)->pPrev = ptr;
                    ptr->pNext = temp->pNext;
                    ptr->pPrev = temp;
                    temp->pNext = ptr;
                }
            }
        }
    }

    return return_val;
}

struct student searchByIdNode(int id) {
    struct node *pTemp = pHead;
    struct student s;
    s.id = -1;

    while (pTemp && pTemp->stu.id != id) {
        pTemp = pTemp->pNext;
    }

    if (pTemp) {
        s = pTemp->stu;
    }

    return s;
}

struct student searchByNameNode(char name[]) {
    struct node *temp = pHead;
    struct student s;
    strcpy(s.name, "");

    while (temp && (strcmp(temp->stu.name, name) != 0)) {
        temp = temp->pNext;
    }

    if (temp) {
        s = temp->stu;
    }

    return s;
}

int deleteNode(int loc) {
    int return_val = 0, i;
    struct node *temp;

    if (loc == 0) {
        return_val = 1;
        if (pHead == NULL) {
            return 0; // List is empty
        }

        temp = pHead;

        if (pHead->pNext == NULL) {
            // Only one node in the list
            free(pHead);
            pHead = pTail = NULL;
        } else {
            pHead = pHead->pNext;
            pHead->pPrev = NULL;
            free(temp);
        }
    } else {
        temp = pHead;

        for (i = 0; (i < loc) && temp; i++) {
            temp = temp->pNext;
        }

        if (temp) {
            return_val = 1;
            if (temp == pTail) {
                pTail = pTail->pPrev;
                if (pTail) {
                    pTail->pNext = NULL;
                }
            } else if (temp == pHead) {
                pHead = pHead->pNext;
                pHead->pPrev = NULL;
            } else {
                (temp->pPrev)->pNext = temp->pNext;
                (temp->pNext)->pPrev = temp->pPrev;
            }

           

 free(temp);
        }
    }

    return return_val;
}

void freeList(void) {
    struct node *temp;
    while (pHead) {
        temp = pHead;
        pHead = pHead->pNext;
        free(temp);
    }
    pTail = NULL;
}

void printList(void) {
    struct node *temp = pHead;
    while (temp) {
        print_student(temp->stu);
        temp = temp->pNext;
    }
}

int deleteNodeById(int id) {
    int return_val = 0;
    struct node *temp = pHead;

    // Find the node with the given ID
    while (temp && temp->stu.id != id) {
        temp = temp->pNext;
    }

    // If the node is found, delete it
    if (temp) {
        return_val = 1;
        if (temp == pHead) {
            pHead = pHead->pNext;
            if (pHead) {
                pHead->pPrev = NULL;
            }
        } else if (temp == pTail) {
            pTail = pTail->pPrev;
            if (pTail) {
                pTail->pNext = NULL;
            }
        } else {
            (temp->pPrev)->pNext = temp->pNext;
            (temp->pNext)->pPrev = temp->pPrev;
        }

        free(temp);
    }

    return return_val;
}

